1、什么是数据库三范式(Normal form)？
	第一范式（1NF）：字段具有原子性，不可再分。所有关系型数据库系统都满足第一范式）
		数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，
		无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。
		
	第二范式（2NF）：先满足第一范式（1NF），非主属性如果依赖于主键，则必须依赖于所有主键，
	不能存在依赖部分主键的情况。
	
	第三范式（3NF）：先满足第二范式（2NF），一个数据库表中不包含已在其它表中
	已包含的非主关键字信息，即消除冗余。
	
	
2、用过哪些RDBMS？用过哪些NoSql产品？它们的主要应用场景是什么？
	RDBMS:oracle、mysql、sql server、db2...
		主要应用场景：
	NoSql:
		Redis： 通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希
		(Hash/Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)五种类型，
		操作非常方便。
			优点：
				1. 提供非常丰富的数据结构；
				2. Redis提供了事务的功能，可以保证一串 命令的原子性，中间不会被任何操作打断。
				3. 数据存在内存中，读写非常的高速。
			缺点：
				1.由于是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然
				redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，
				需要定期删除数据。
				2. 持久化功能体验不佳——通过快照方法实现的话，需要每隔一段时间将整个数据库的数据写到
				磁盘上，代价非常高。
			适用场景：
				适用于数据变化快且数据库大小可预见（适合内存容量）的应用程序。比如：会话缓存
				（Session Cache）、全页缓存（FPC）、排行榜/计数器、发布/订阅等。
				
		 MongoDB：MongoDB 是一个高性能，开源，无模式的文档型数据库。它在许多场景下可用于
		 替代传统的关系型数据库或键/值存储方式。
		 	优点：
		 		1. 强大的自动化 shading 功能；
				2. 全索引支持，查询非常高效；
				3. 面向文档（BSON）存储，数据模式简单而强大。
				4. 支持动态查询，查询指令也使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。
				5. 支持 javascript 表达式查询，可在服务器端执行任意的 javascript函数。
		 	缺点：
		 		1. 单个文档大小限制为16M，32位系统上，不支持大于2.5G的数据；
				2. 对内存要求比较大，至少要保证热数据（索引，数据及系统其它开销）都能装进内存；
				3. 非事务机制，无法保证事件的原子性。
			适用场景：	
				游戏场景：使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式
				存储，方便查询、更新。
				物流场景：使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 
				MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。
				社交场景：使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置
				索引实现附近的人、地点等功能。
				物联网场景：使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并
				对这些信息进行多维度的分析
				视频直播：使用 MongoDB 存储用户信息、礼物信息等

				
		HBase：是 Apache Hadoop 中的一个子项目，属于 bigtable 的开源版本，。HBase
		依托于 Hadoop 的 HDFS（分布式文件系统）作为最基本存储基础单元。HBase在列上实现了 
		BigTable 论文提到的压缩算法、内存操作和布隆过滤器。HBase的表能够作为 MapReduce任务
		的输入和输出，可以通过Java API来访问数据，也可以通过REST、Avro或者Thrift的API来
		访问。
			优点：
				1. 存储容量大，一个表可以容纳上亿行，上百万列；
				2. 可通过版本进行检索，能搜到所需的历史版本数据；
				3. 负载高时，可通过简单的添加机器来实现水平切分扩展，跟Hadoop的无缝集成保障
				了其数据可靠性（HDFS）和海量数据分析的高性能（MapReduce）。
			缺点：
				1.占用内存很大，且鉴于建立在为批量分析而优化的HDFS上，导致读取性能不高；
				2. API相比其它 NoSql 的相对笨拙。
			适用场景：	
				1. bigtable类型的数据存储；
				2. 对数据有版本查询需求；
				3. 应对超大数据量要求扩展简单的需求。

3、基础sql语句？
	DDL(data definition language)
	创建数据库：
		CREATE DATABASE 数据库名
		
	创建数据表：
	修改数据表：
	
	DML(data manipulation language)
	增加：
		INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)
	删除：
		DELETE FROM 表名称 WHERE 列名称 = 值
	修改：
		UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值
	查询：
		SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 ORDER BY 列名 ASC|DESC
		
	分页：
		mysql:
			select * from user_detail where user_id limit 0,20

		oracle:
			SELECT * FROM
			(
			   SELECT A.*, ROWNUM RN
			   FROM (SELECT * FROM TABLE_NAME) A
			   WHERE ROWNUM <= 40
			)
			WHERE RN >= 21

			SELECT * FROM
			(
			   SELECT A.*, ROWNUM RN
			   FROM (SELECT * FROM TABLE_NAME) A
			)
			WHERE RN BETWEEN 21 AND 40
		
	去重：
	
	
4、sql语句中的连接方式有哪几种，之间有什么区别与联系？
	外连接(outer join)：
		左连接(left join/left outer join):
			返回的结果会包含左表中所有符合条件的列，如果左表的某行在右表中没有匹配行，则在相关联
			的结果集行中右表的所有选择列表列均为空值。
			select * from table1 left join table2 on table1.id=table2.id
			
		右连接(right join/right outer join):
			返回的结果会包含右表中所有符合条件的列，如果右表的某行在左表中没有匹配行，则在相关联
			的结果集行中左表的所有选择列表列均为空值。
			select * from table1 right join table2 on table1.id=table2.id
			
		全外连接(full join/full outer join):
			返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列均为
			空值。
			select * from table1 full join table2 on table1.id=table2.id
			
	内连接(inner join)：
		内联接是用比较运算符比较要联接列的值的联接
		select * from table1 join table2 on table1.id=table2.id
		select a.*,b.* from table1 a,table2 b where a.id=b.id
		select * from table1 cross join table2 where table1.id=table2.id
		*：cross join后加条件只能用where,不能用on
		
	交叉连接(cross join):
		返回的是两表的乘积，也叫笛卡尔积
		select * from table1 cross join table2
		select * from table1,table2		
	
5、truncate 、delete与drop区别？
	相同点：truncate和不带where子句的delete、以及drop都会删除表数据。
	
	不同点：
	1、truncate 和 delete 只删除数据不删除表的结构(定义)drop 语句将删除表的结构被依赖
	的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,
	但是变为 invalid 状态。
	2、速度，一般来说: drop> truncate > delete
	3、delete 语句是数据库操作语言(dml)，这个操作会放到 回滚段中，事务提交之
	后才生效；如果有相应的 触发器，执行的时候将被触发。truncate、drop 是数据库定义语言
	(ddl)，操作立即生效，原数据不放到回滚段中，不能回滚，操作不触发 触发器。	
	
6、如果一个SQL执行时间比较长怎么办？

7、触发器和存储过程？

8、在什么情况下需要视图？


	