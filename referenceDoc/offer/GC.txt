1、Java 中会存在内存泄漏吗，请简单描述。
	理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的
	一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致
	内存泄露的发生。例如hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收
	这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级
	缓存就可能导致内存泄露。
	
	
2、GC是什么？为什么要有GC？
	GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或
	系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目
	的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器
	会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：
	System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。
	垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先
	级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，
	程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是
	Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，
	如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统
	有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。
	
	补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java
	进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基
	用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，
	可能会将对象移动到不同区域：
	- 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。
	- 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。
	- 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触
	及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），
	这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。
	
3、如何判断对象是否存活？
	引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为
	0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
	
	可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径
	称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达
	对象。
	
4、常用的GC算法？
	标记 -清除算法：“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清
	除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
	
	复制算法：“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次
	只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把
	已使用过的内存空间一次清理掉。
	
	标记-压缩算法：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清
	理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
	
	分代收集算法：“分代收集”（Generational Collection）算法，把Java堆分为新生代
	和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
	
5、垃圾回收器？
	Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只
	使用一个线程去回收。
	
	ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。
	
	Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器
	更关注系统的吞吐量。
	
	Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，
	使用多线程和“标记－整理”算法
	
	CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为
	目标的收集器。
	
	G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理
	器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征
	
	
	