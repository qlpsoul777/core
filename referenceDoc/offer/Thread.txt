1、举例说明同步和异步？
	如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个
	线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作
	中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望
	让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的
	同步就是指阻塞式操作，而异步就是非阻塞式操作。

2、进程与线程的区别？
	一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中
	拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
	线程在执行过程中与进程的区别在于每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但
	是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
	从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多
	个线程看做多个独立的应用来实现进程的调度和管理以及资源分配。

3、线程的基本状态以及状态之间的关系？
	新建：
		用new语句创建的线程对象处于新建状态，此时它和其他Java对象一样，仅被分配了内存。
	等待：
		当线程在new之后，并且在调用start方法前，线程处于等待状态。
	就绪：(Runnable,万事俱备，只欠CPU)
		当一个线程对象创建后，其他线程调用它的start()方法，该线程就进入就绪状态。处于这个状态的
		线程位于Java虚拟机的可运行池中，等待cpu的使用权。
	运行：(Running)
		 处于这个状态的线程占用CPU，执行程序代码。在并发运行环境中，如果计算机只有一个CPU，那么任
		 何时刻只会有一个线程处于这个状态。只有处于就绪状态的线程才有机会转到运行状态。
	阻塞：(Blocked)
		 阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。当线程处于阻塞状态时，Java虚拟机不会
		 给线程分配CPU，直到线程重新进入就绪状态，它才会有机会获得运行状态。
		阻塞状态分为三种:
		1、等待阻塞:运行的线程执行wait（）方法，JVM会把该线程放入等待池中。
		2、同步阻塞:运行的线程在获取对象同步锁时，若该同步锁被别的线程占用，则JVM会把线程放入锁池
		中。
		3、其他阻塞:运行的线程执行Sleep（）方法，或者发出I/O请求时，JVM会把线程设为阻塞状态。
		当Sleep（）状态超时、或者I/O处理完毕时，线程重新转入就绪状态。
	死亡：
		当线程执行完run()方法中的代码，或者遇到了未捕获的异常，就会退出run()方法，此时就进入
		死亡状态，该线程结束生命周期。

4、编写多线程程序有几种实现方式？
	Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方
	式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一
	个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。Java 5以
	后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个
	返回值。

5、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?
	sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，
	将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就
	绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法
	导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的
	notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），
	如果线程重新获得对象的锁就可以进入就绪状态。

6、线程的sleep()方法和yield()方法有什么区别？
	① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；
	yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
	② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）
	状态；
	③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
	④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

7、notify和notityAll？
	- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状
	态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；
	- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，
	只有获得锁的线程才能进入就绪状态；

8、什么是线程池（thread pool）？
	在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。
	在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务
	程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就
	是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，
	需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线
	程对象的开销。
	Java 5+中的Executor接口定义一个执行线程的工具。
	它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的
	原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，
	如下所示：
	- newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，
	也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程
	来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
	- newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到
	线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线
	程池会补充一个新线程。
	- newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线
	程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线
	程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创
	建的最大线程大小。
	- newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务
	的需求。
	- newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务
	的需求。

9、简述synchronized 和java.util.concurrent.locks.Lock的异同？
	Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成
	synchronized所实现的所有功能；
	主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要
	获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 
	块中释放（这是释放外部资源的最好的地方）。

10、简述ThreadLocal？
	ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。ThreadLocal，顾名思义是线程的一个本地化对象，
	当工作于多线程中的对象使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程分配一个独立的变量
	副本，所以每一个线程都可以独立的改变自己的副本，而不影响其他线程所对应的副本。从线程的角度看，这个变量就像是
	线程的本地变量。
	
	ThreadLocal类非常简单好用，只有四个方法，能用上的也就是下面三个方法：
		- void set(T value)：设置当前线程的线程局部变量的值。
		- T get()：获得当前线程所对应的线程局部变量的值。
		- void remove()：删除当前线程中线程局部变量的值。