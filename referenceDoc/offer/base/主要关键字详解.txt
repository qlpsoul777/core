1、static?
	static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，
	特殊情况下也可以修饰类。
	a、被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：
		对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变
		量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。对于实例变
		量，没创建一个实例，就会为实例变量分配       一次内存，实例变量可以在内存中有多个拷贝
		，互不影响（灵活）。
	b、静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，
	不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的
	静态成员变量和成员方法。
	c、static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，
	它不在任何的方法体内， JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们
	在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。
	d、static修饰类时只能修饰内部类，被修饰的类通常称为静态内部类，或者叫静态嵌套类。


2、final?
	final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。
	a、final修饰类，表示该类不能被继承，final类的成员方法没有机会被覆盖，默认都是final的。
	在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，
	那么就设计为final类。
	b、final修饰方法，表示方法不能被覆盖，使用final方法的原因有二：
		第一、把方法锁定，防止任何继承类修改它的意义和实现。
		第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。
	c、final修饰的成员变量表示常量，值一旦给定就无法改变！final变量定义的时候，可以先声明，
	而不给初值，这种变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。
	但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final
	数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。
	d、final修饰参数，表示可以读取使用该参数，但是无法改变该参数的值。


3、abstract?
	abstract有“抽象的”含义，它可以修饰类和方法。
	a、abstract修饰类，表示该类是一个抽象类，此类必须被继承使用。此类不可生成对象。 abstract可以
	将子类的共性最大限度的抽取出来，放在父类中，以提高程序的简洁性。 abstract虽然不能生成对象，
	但是可以声明，作为编译时类型，但不能作为运行时类型。final和abstract永远不会同时出现。
	b、当abstract用于修饰方法时，此时该方法为抽象方法，此时方法不需要实现，实现留给子类覆盖，子类覆
	盖该方法之后方法才能够生效。由于static方法是属于类的，是静态方法，而abstract是等着被子类实
	现的，隐含了一种动态的意思，所以修饰方法时，两者不可能共存。


4、transient？
	Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，
	我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域
	前加上关键字transient。transient是Java语言的关键  字，用来表示一个域不是该对象串行化的一部分。
	当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是
	被包括进去的(static的除外)。

5、volatile？
	1.volatile关键字的两层语义:
    	一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
    　　	1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来
    	说是立即可见的。
    	2）禁止进行指令重排序。

    2.volatile的原理和实现机制
    	“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，
    	会多出一个lock前缀指令”
    　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
    　　	1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存
    	屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
    　　	2）它会强制将对缓存的修改操作立即写入主存；
    	3）如果是写操作，它会导致其他CPU中对应的缓存行无效。

    3.	volatile的适用场景
    1）对变量的写操作不依赖与当前值或者能保证只有单个线程更新变量的值
    2)该变量不会与其他状态变量一起参与不变性条件中。

    4.volatile只能保证可见性，不能保证操作的原子性。


6、synchronized？
	1. 在Java中，每一个对象都拥有一个锁标记（monitor），也称为监视器，多线程同时访问某个对象时，线程只有获取
	了该对象的锁才能访问。
    在Java中，可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法
    或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个
    方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。

    2. synchronized用法
    1）对于锁普通方法，锁是当前实例对象
    2）对于锁静态方法，锁是当前类的Class对象
    3）对于锁代码块，锁是括号里配置的对象

    3．注意事项
    1）当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法。
    这个原因很简单，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，
    所以无法访问该对象的其他synchronized方法。
    2）当一个线程正在访问一个对象的synchronized方法，那么其他线程能访问该对象的非synchronized方法。
    这个原因很简单，访问非synchronized方法不需要获得该对象的锁，假如一个方法没用synchronized关键字修饰，
    说明它不会使用到临界资源，那么其他线程是可以访问这个方法的，
    3）如果一个线程A需要访问对象object1的synchronized方法fun1，另外一个线程B需要访问对象object2的
    synchronized方法fun1，即使object1和object2是同一类型），也不会产生线程安全问题，因为他们访问的
    是不同的对象，所以不存在互斥问题。
    4）对于synchronized方法或者synchronized代码块，当出现异常时，JVM会自动释放当前线程占用的锁，因此不
    会由于异常导致出现死锁现象。



7、final, finally, finalize的区别。
	final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。
	
	finally是异常处理语句结构的一部分，表示总是执行。
	
	finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，
	可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用。
	